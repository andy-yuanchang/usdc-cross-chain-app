import { EthereumProvider } from '@walletconnect/ethereum-provider'
import { createWalletClient, custom } from 'viem'
import { mainnet } from 'viem/chains'
import { useAtom, useSetAtom } from 'jotai'
import { connectingAtom, errorAtom, walletClientAtom, addressAtom, currentChainAtom } from '@/atoms/wallet'
import type { WalletHooks } from '@/types/wallet'
import { SUPPORTED_CHAINS, WALLET_CONNECT_PROJECT_ID } from '@/constants'
import { getChain } from '@/utils'

interface WalletConnectParams {
  onClose: () => void
}

export default function useWalletConnect({ onClose }: WalletConnectParams): WalletHooks {
  const [currentChain, setCurrentChain] = useAtom(currentChainAtom)
  const setConnecting = useSetAtom(connectingAtom)
  const setWalletClient = useSetAtom(walletClientAtom)
  const setError = useSetAtom(errorAtom)
  const setAccounts = useSetAtom(addressAtom)
  return {
    name: 'Wallet Connect',
    connect: async () => {
      setConnecting(true);
      try {
        const provider = await EthereumProvider.init({
          chains: [...SUPPORTED_CHAINS.map(chain => chain.id)],
          projectId: WALLET_CONNECT_PROJECT_ID,
          showQrModal: true,
        } as any);

        provider.on('chainChanged', (chainId: string) => {
          setCurrentChain(getChain(+chainId));
        });

        await provider.connect();

        const walletClient = createWalletClient({
          chain: currentChain ?? mainnet,
          transport: custom(provider),
        });

        if (!walletClient) {
          return;
        }
        setWalletClient(walletClient);
        const accounts = await walletClient.requestAddresses();
        setAccounts(accounts);
        onClose();
      } catch (error: unknown) {
        if (error instanceof Error)
          setError(error as Error);
        setError(new Error(error as string))
      } finally {
        setConnecting(false);
      }
    },
  }
}